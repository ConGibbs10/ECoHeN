# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Count stubs for p-value computation using corollary.
#'
#' @details Counts the number of colored stubs for each color emanating from each
#' node which connects to a provided set of nodes in the observed graph, excluding
#' any stub which could result in a self-loop.
#'
#' @param B0 Vector of vertices representing the candidate community.
#' @param G_stats List of graph statistics returned from `eval_G`.
#'
#' @export
#' @keywords internal
count_stubs_for_B0minusv_cpp <- function(B0, G_stats) {
    .Call(`_ECoHeN_count_stubs_for_B0minusv_cpp`, B0, G_stats)
}

#' Count stubs for p-value computation using theorem.
#'
#' @details Counts the number of colored stubs for each color emanating from each
#' node which connects to a provided set of nodes in the observed graph.
#'
#' @param B0 Vector of vertices representing the candidate community.
#' @param G_stats List of graph statistics returned from `eval_G`.
#'
#' @export
#' @keywords internal
count_stubs_for_B0_cpp <- function(B0, G_stats) {
    .Call(`_ECoHeN_count_stubs_for_B0_cpp`, B0, G_stats)
}

#' Evaluates the exponential decay function at the current iteration.
#'
#' @param epoch Integer for iteration.
#' @param learning_rate Double for the learning rate.
#' @param decay_rate Double for the decay rate.
#'
#' @export
#' @keywords internal
lrd <- function(epoch, learning_rate, decay_rate) {
    .Call(`_ECoHeN_lrd`, epoch, learning_rate, decay_rate)
}

#' Checks if the extraction procedure converged.
#'
#' @param x An integer vector of nodes.
#' @param y An integer vector of nodes.
#' @param z An integer vector of nodes.
#'
#' @export
#' @keywords internal
is_stable <- function(x, y, z) {
    .Call(`_ECoHeN_is_stable`, x, y, z)
}

#' Checks if the extraction procedure reached a cycle.
#'
#' @param x An integer vector of nodes.
#' @param y An integer vector of nodes.
#' @param z An integer vector of nodes.
#'
#' @export
#' @keywords internal
is_cycle <- function(x, y, z) {
    .Call(`_ECoHeN_is_cycle`, x, y, z)
}

#' Checks if the extraction procedure reached empty.
#'
#' @param x An integer vector of nodes.
#'
#' @export
#' @keywords internal
is_empty <- function(x) {
    .Call(`_ECoHeN_is_empty`, x)
}

#' ECoHeN extraction procedure.
#'
#' @param alpha Double of significance level.
#' @param B0 Vector of vertices representing the candidate community.
#' @param G_stats List of graph statistics returned from `eval_G`.
#' @param learning_rate Double between 0 and 1 dictating the maximal allowance on the first iteration.
#' @param decay_rate Double between 0 and 1 dictating the maximal allowance after the first iteration.
#' @param adj_method String scalar for the desired multiple correction method. See `p.adjust.methods` for options.
#' @param max_iter Integer scalar for the maximum number of iterations before halting the extraction procedure. int max_iter, Rcpp::String adj_method
#'
#' @export
main_search_decay_cpp <- function(alpha, B0, G_stats, learning_rate, decay_rate, adj_method, max_iter) {
    .Call(`_ECoHeN_main_search_decay_cpp`, alpha, B0, G_stats, learning_rate, decay_rate, adj_method, max_iter)
}

#' Identifies the smallest indices in a vector.
#'
#' @details Identifies the indices of the N smallest values in a double vector x,
#' breaking ties uniformly at random. Uses a full sort.
#'
#' @param Vector of doubles.
#' @param Integer for the number of indices to identify.
#'
#' @export
#' @keywords internal
smallest_indices1 <- function(x, N) {
    .Call(`_ECoHeN_smallest_indices1`, x, N)
}

#' Identifies the smallest indices in a vector.
#'
#' @details Identifies the indices of the N smallest values in a double vector x,
#' breaking ties uniformly at random. Uses a partial sort.
#'
#' @param Vector of doubles.
#' @param Integer for the number of indices to identify.
#'
#' @export
#' @keywords internal
smallest_indices2 <- function(x, N) {
    .Call(`_ECoHeN_smallest_indices2`, x, N)
}

#' Converts C++ indices to R indices by adding one.
#'
#' @param x Integer vector.
#'
#' @export
#' @keywords internal
index_Cpp2R <- function(x) {
    .Call(`_ECoHeN_index_Cpp2R`, x)
}

#' Converts R indices to C++ by subtracting one.
#'
#' @param x Integer vector.
#'
#' @export
#' @keywords internal
index_R2Cpp <- function(x) {
    .Call(`_ECoHeN_index_R2Cpp`, x)
}

#' Concatenates two integer vectors.
#'
#' @param x Integer vector.
#' @param y Integer vector.
#'
#' @export
#' @keywords internal
c_integer <- function(x, y) {
    .Call(`_ECoHeN_c_integer`, x, y)
}

#' Construct logical vector by comparing a character vector to a string.
#'
#' @param x Character vector.
#' @param s String.
#'
#' @export
#' @keywords internal
vector_equals_string <- function(x, s) {
    .Call(`_ECoHeN_vector_equals_string`, x, s)
}

#' Indices of TRUE values in a logical vector.
#'
#' @param x Logical vector.
#'
#' @export
#' @keywords internal
which_true <- function(x) {
    .Call(`_ECoHeN_which_true`, x)
}

#' Subset a matrix.
#'
#' @param M Integer matrix.
#' @param rows Integer vector of rows in C++ indices.
#' @param cols Integer vector of columns in C++ indices.
#'
#' @export
#' @keywords internal
subset_matrix <- function(M, rows, cols) {
    .Call(`_ECoHeN_subset_matrix`, M, rows, cols)
}

